/**
An Extention which provides a RESTful HTTP sync implementation that can be mixed
into a Model or ModelList subclass.

If the communication with the server is done via JSON, only the `root` and `url`
prototype properties will need to be assigned to match your server's URL space.

@module model-sync

@TODO: Rename to something like ModelRESTSync? ModelHTTPSync? RESTSync?
**/

var ModelSync,

    Lang        = Y.Lang,
    sub         = Lang.sub,
    isFunction  = Lang.isFunction;

/**
Providesâ€¦

@class ModelSync
@extension
**/
ModelSync = function(){};

/**
Static hash lookup table of RESTful HTTP methods corresponding to CRUD actions.

@property HTTP_METHODS
@type Object
@static
**/
ModelSync.HTTP_METHODS = {
    'create': 'POST',
    'read'  : 'GET',
    'update': 'PUT',
    'delete': 'DELETE'
};

ModelSync.prototype = {

    /**
    A String which represents the root or collection part of the URL space which
    relates to a Model or ModelList. Usually this value should be same for all
    instances of a specific Model/ModelList type.

    When subclassing Y.Model, most of the time you'll want to just override this
    property, and let the URLs for the XHRs be generated by convention. If the
    `root` String ends with a trailing-slash, XHR URLs will also end with a '/';
    if the `root` does not end with a slash, neither will the XHR URLs.

    @example
        var User = Y.Base.create('user', Y.Model, [Y.ModelSync], {
            root : '/user/'
        }, {
            ATTRS : {
                name : {}
            }
        });

        var myUser = new User({ id: '123' });
        myUser.load(); // will GET the User data from: /user/123/

        var newUser = new User({ name: 'Eric Ferraiuolo' });
        newUser.save(); // will POST the User data to: /user/

    When sublcassing Y.ModelList, usually you'll want to ignore configuring the
    `root` and instead just set the `url` to a String; but if you just specify a
    value for `root`, things will work correctly.

    @property root
    @type String
    @default ''
    **/
    root : '',

    /**
    A Function or String which is used to generate or specify the URL for the
    XHRs. While, this property can be defined for each Model/ModelList instance,
    usually you'll want to use a Function or patterned-String instead.

    If the `url` property is a Function, it should return the String that should
    be used as the URL. The Function will be called before each request.

    If the `url` property is a String, it will be processed by `Y.Lang.sub()`;
    this is useful when the URLs for a Model type match a specific pattern and
    can use simple replacement tokens:

    @example
        '/user/{id}/'

    When subclassing Y.Model, you will probably be able to rely on the default
    implementation which works in conjunction with the `root` property. Your
    URL-space may have plural root or collection URLs, while the specific
    resource are under a singular name, e.g. /users (plural) and /user/123
    (singular); for this you'll probably want to configure the `root` and `url`
    properties like this:

    @example
        var User = Y.Base.create('user', Y.Model, [Y.ModelSync], {
            root : '/users',
            url  : '/user/{id}'
        }, {
            ATTRS : {
                name : {}
            }
        });

        var myUser = new User({ id: '123' });
        myUser.load(); // will GET the User data from: /user/123

        var newUser = new User({ name: 'Eric Ferraiuolo' });
        newUser.save(); // will POST the User data to: /users

    When subclassing Y.ModelList, you probably just need to specify a simple
    String for the `url` property and leave `root` to be the default value.

    @method url
    @return {String} URL to for the XHR to the server.
    **/
    url : function () {
        var root = this.root,
            url;

        if (this instanceof Y.ModelList || this.isNew()) {
            return root;
        }

        url = this.getAsUrl('id');
        if (root && root.charAt(root.length - 1) === '/') {
            // add trailing-slash because root has a trailing-slash
            url += '/';
        }

        return this._joinUrl(url);
    },

    /**
    A hash of HTTP headers which will be used with each XHR.

    These headers are considered the default headers used for each request, but
    they are merged with any request-specific headers which will take presidence
    over these defaults.

    @property headers
    @type Object
    @default
        {
            'Accept'        : 'application/json',
            'Content-Type'  ; 'application/json'
        }
    **/
    headers : {
        'Accept'        : 'application/json',
        'Content-Type'  ; 'application/json'
    },

    /**
    @TODO: Comment for realz!

    Override this method to provide a custom persistence implementation for this
    model. The default just calls the callback without actually doing anything.

    This method is called internally by load(), save(), and destroy().

    @method sync
    @param {String} action Sync action to perform. May be one of the following:

      * create: Store a newly-created model for the first time.
      * delete: Delete an existing model.
      * read  : Load an existing model.
      * update: Update an existing model.

    @param {Object} [options] Sync options. It's up to the custom sync
      implementation to determine what options it supports or requires, if any.
    @param {callback} [callback] Called when the sync operation finishes.
      @param {Error|null} callback.err If an error occurred, this parameter will
        contain the error. If the sync operation succeeded, _err_ will be
        falsy.
      @param {Any} [callback.response] The server's response. This value will
        be passed to the parse() method, which is expected to parse it and
        return an attribute hash.
    **/
    sync : function (action, options, callback) {
        options || (options = {});

        var url     = this._getUrl(),
            method  = ModelSync.HTTP_METHODS[action],
            headers = Y.merge(this.headers, options.headers),
            entity;

        if (method === 'POST' || method === 'PUT') {
            entity = Y.JSON.stringify(this);
        } else {
            // no content is being sent
            delete headers['Content-Type'];
        }

        Y.io(url, {
            method  : method,
            headers : headers,
            data    : entitiy,
            on      : {
                success : function (txId, res) {
                    isFunction(callback) && callback(null, res.responseText);
                },
                failure : function (txId, res) {
                    if (isFunction(callback)) {
                        callback({
                            code: res.status,
                            msg : res.statusText
                        }, res.responseText);
                    }
                }
            }
        });
    },

    /**
    Helper method to return the URL to be used to make the XHR to the server.

    @method _getUrl
    @return {String} the URL for the XHR
    @protected
    **/
    _getUrl : function () {
        var url = this.url,
            data;

        if (isFunction(url)) {
            return url();
        }

        if (this instanceof Y.Model) {
            data = this.toJSON();
            Y.Object.each(data, function (v, k) {
                // replace the value with URL-encoded ones before we substitute.
                data[k] = this.getAsUrl(k);
            }, this);

            // substitute place-holders with the data values.
            url = sub(url, data);
        }

        return url || this.root;
    },

    /**
    @TODO: Add Attribution, since it's copied!

    Joins the `root` URL to the specified _url_, normalizing leading/trailing
    `/` characters.

    Copied from `Y.Controller`:

    @example
        model.root = '/foo'
        model._joinURL('bar');  // => '/foo/bar'
        model._joinURL('/bar'); // => '/foo/bar'

        model.root = '/foo/'
        model._joinURL('bar');  // => '/foo/bar'
        model._joinURL('/bar'); // => '/foo/bar'

    @method _joinURL
    @param {String} url URL to append to the `root` URL.
    @return {String} Joined URL.
    @protected
    **/
    _joinURL: function (url) {
        var root = this.root;

        if (url.charAt(0) === '/') {
            url = url.substring(1);
        }

        return root && root.charAt(root.length - 1) === '/' ?
                root + url :
                root + '/' + url;
    },

};

// Namespace
Y.ModelSync = ModelSync;
