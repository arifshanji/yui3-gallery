/**
An Extention which provides a RESTful HTTP sync implementation that can be mixed
into a Model or ModelList subclass.

@module gallery-model-sync-rest
**/

var Rest,

    Lang        = Y.Lang,
    sub         = Lang.sub,
    isString    = Lang.isString,
    isNumber    = Lang.isNumber,
    isFunction  = Lang.isFunction;

/**
Providesâ€¦

@class ModelSync.Rest
@extension
**/
Rest = function(){};

/**
Static hash lookup table of RESTful HTTP methods corresponding to CRUD actions.

@property HTTP_METHODS
@type Object
@static
**/
Rest.HTTP_METHODS = {
    'create': 'POST',
    'read'  : 'GET',
    'update': 'PUT',
    'delete': 'DELETE'
};

/**
Static flag to use the HTTP POST method instead of PUT or DELETE.

If the server-side HTTP framework isn't RESTful, setting this flag to `ture`
will cause all PUT and DELETE requests to instead use the POST HTTP method, and
add a X-HTTP-Method-Override HTTP header with the value of the method type which
was overriden.

@property EMULATE_HTTP
@type Boolean
@default false
@static
**/
Rest.EMULATE_HTTP = false;

Rest.prototype = {

    /**
    A String which represents the root or collection part of the URL space which
    relates to a Model or ModelList. Usually this value should be same for all
    instances of a specific Model/ModelList type.

    When subclassing Y.Model, most of the time you'll want to just override this
    property, and let the URLs for the XHRs be generated by convention. If the
    `root` String ends with a trailing-slash, XHR URLs will also end with a '/';
    if the `root` does not end with a slash, neither will the XHR URLs.

    @example
        var User = Y.Base.create('user', Y.Model, [Y.ModelSync.Rest], {
            root : '/user/'
        }, {
            ATTRS : {
                name : {}
            }
        });

        var myUser = new User({ id: '123' });
        myUser.load(); // will GET the User data from: /user/123/

        var newUser = new User({ name: 'Eric Ferraiuolo' });
        newUser.save(); // will POST the User data to: /user/

    When sublcassing Y.ModelList, usually you'll want to ignore configuring the
    `root` and instead just set the `url` to a String; but if you just specify a
    value for `root`, things will work correctly.

    @property root
    @type String
    @default ''
    **/
    root : '',

    /**
    A Function or String which is used to generate or specify the URL for the
    XHRs. While, this property can be defined for each Model/ModelList instance,
    usually you'll want to use a Function or patterned-String instead.

    If the `url` property is a Function, it should return the String that should
    be used as the URL. The Function will be called before each request.

    If the `url` property is a String, it will be processed by `Y.Lang.sub()`;
    this is useful when the URLs for a Model type match a specific pattern and
    can use simple replacement tokens:

    @example
        '/user/{id}/'

    **Note:** Only String and Number ATTR values will be substituded; do not
    expect something fancy to happen with Object, Array, or Boolean values, they
    will simply be ingored.

    When subclassing Y.Model, you will probably be able to rely on the default
    implementation which works in conjunction with the `root` property. Your
    URL-space may have plural root or collection URLs, while the specific
    resource are under a singular name, e.g. /users (plural) and /user/123
    (singular); for this you'll probably want to configure the `root` and `url`
    properties like this:

    @example
        var User = Y.Base.create('user', Y.Model, [Y.ModelSync.Rest], {
            root : '/users',
            url  : '/user/{id}'
        }, {
            ATTRS : {
                name : {}
            }
        });

        var myUser = new User({ id: '123' });
        myUser.load(); // will GET the User data from: /user/123

        var newUser = new User({ name: 'Eric Ferraiuolo' });
        newUser.save(); // will POST the User data to: /users

    When subclassing Y.ModelList, you probably just need to specify a simple
    String for the `url` property and leave `root` to be the default value.

    @method url
    @return {String} URL to for the XHR to the server.
    **/
    url : function () {
        var root = this.root,
            url;

        if (this instanceof Y.ModelList || this.isNew()) {
            return root;
        }

        url = this.getAsUrl('id');
        if (root && root.charAt(root.length - 1) === '/') {
            // add trailing-slash because root has a trailing-slash
            url += '/';
        }

        return this._joinUrl(url);
    },

    /**
    A hash of HTTP headers which will be used with each XHR.

    These headers are considered the default headers used for each request, but
    they are merged with any request-specific headers which will take presidence
    over these defaults.

    @property headers
    @type Object
    @default
        {
            'Accept'        : 'application/json',
            'Content-Type'  ; 'application/json'
        }
    **/
    headers : {
        'Accept'        : 'application/json',
        'Content-Type'  : 'application/json'
    },

    /**
    @TODO: Comment for realz!

    Override this method to provide a custom persistence implementation for this
    model. The default just calls the callback without actually doing anything.

    This method is called internally by load(), save(), and destroy().

    @method sync
    @param {String} action Sync action to perform. May be one of the following:

      * create: Store a newly-created model for the first time.
      * delete: Delete an existing model.
      * read  : Load an existing model.
      * update: Update an existing model.

    @param {Object} [options] Sync options. It's up to the custom sync
      implementation to determine what options it supports or requires, if any.
    @param {callback} [callback] Called when the sync operation finishes.
      @param {Error|null} callback.err If an error occurred, this parameter will
        contain the error. If the sync operation succeeded, _err_ will be
        falsy.
      @param {Any} [callback.response] The server's response. This value will
        be passed to the parse() method, which is expected to parse it and
        return an attribute hash.
    **/
    sync : function (action, options, callback) {
        options || (options = {});

        var url     = this._getUrl(),
            method  = Rest.HTTP_METHODS[action],
            headers = Y.merge(this.headers, options.headers),
            entity;

        if (method === 'POST' || method === 'PUT') {
            entity = Y.JSON.stringify(this);
        } else {
            // no content is being sent
            delete headers['Content-Type'];
        }

        if (Rest.EMULATE_HTTP && (method === 'PUT' || method === 'DELETE')) {
            // pass along original method type in the headers
            headers['X-HTTP-Method-Override'] = method;
            // fallback to POST method type
            method = 'POST';
        }

        Y.io(url, {
            method  : method,
            headers : headers,
            data    : entity,
            on      : {
                success : function (txId, res) {
                    if (isFunction(callback)) {
                        callback(null, res.responseText);
                    }
                },
                failure : function (txId, res) {
                    if (isFunction(callback)) {
                        callback({
                            code: res.status,
                            msg : res.statusText
                        }, res.responseText);
                    }
                }
            }
        });
    },

    /**
    Helper method to return the URL to be used to make the XHR to the server.

    @method _getUrl
    @return {String} the URL for the XHR
    @protected
    **/
    _getUrl : function () {
        var url = this.url,
            data;

        if (isFunction(url)) {
            return url();
        }

        if (this instanceof Y.Model) {
            data = {};
            Y.Object.each(this.toJSON(), function (v, k) {
                if (isString(v) || isNumber(v)) {
                    // URL-encode any String or Number values.
                    data[k] = encodeURIComponent(v);
                }
            });

            // substitute placeholders with the data values.
            url = sub(url, data);
        }

        return url || this.root;
    },

    /**
    @TODO: Add Attribution, since it's copied!

    Joins the `root` URL to the specified _url_, normalizing leading/trailing
    `/` characters.

    Copied from `Y.Controller`:

    @example
        model.root = '/foo'
        model._joinURL('bar');  // => '/foo/bar'
        model._joinURL('/bar'); // => '/foo/bar'

        model.root = '/foo/'
        model._joinURL('bar');  // => '/foo/bar'
        model._joinURL('/bar'); // => '/foo/bar'

    @method _joinURL
    @param {String} url URL to append to the `root` URL.
    @return {String} Joined URL.
    @protected
    **/
    _joinURL: function (url) {
        var root = this.root;

        if (url.charAt(0) === '/') {
            url = url.substring(1);
        }

        return root && root.charAt(root.length - 1) === '/' ?
                root + url :
                root + '/' + url;
    }

};

// Namespace
Y.namespace('ModelSync.Rest') = Rest;
